<!DOCTYPE html>
<html lang="zh-CN">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>kibana console api LFI (CVE-2018-17246) &ndash; # alert`D0n9` ｜ 输攻墨守</title>
	<link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/nav.css">
    
    
    
    
    
	<link rel="stylesheet" href="/css/themes/light.css">
</head>
<body>
	<input class="show-hide-menu-input" style="display:none;" autocomplete="off" type="checkbox" id="toggle-1">
	<label class="overlay" for="toggle-1"></label>
	<div class="main">
		<header class="header">
			<div class="header-content">
				<div class="title">
					<a href="http://localhost:1313/"># alert`D0n9` ｜ 输攻墨守</a>
				</div>
				<div>
					<div class="header-right">
						<label id="show-hide-menu-label" class="clickable-header-label" for="toggle-1">
							<img class="color-adapting-image" width="30" src="/images/hamburger.svg" alt="menu button">
						</label>
					</div>
					<div class="dont-show">
						<p>
							Links:
						</p>
					</div>
					<ul class="links">
						<li><a href="/">Home</a></li>
						<li><a href="/posts/">Posts</a></li>
						<li><a href="/about-me/">About Me</a></li>
						<li><a href="/tags/">Tags</a></li>
					</ul>
				</div>
			</div>
		</header>
		<main class="body">
			<div class="body-content">
  <header class="title-header">
    <h1>kibana console api LFI (CVE-2018-17246)</h1>
    <div class="title-header-date">
        <time>Friday, December 21, 2018</time>
    </div>
    
  </header>
  <h2 id="背景">背景<aside class="heading-anchor"><a href="#背景" aria-label="Anchor"><img src="/images/chain-link.svg" class="color-adapting-image" height="20"></a></aside></h2>
<p>该漏洞由 CyberArk Labs 实验室 Nethanel Coppenhagen 发现 （https://www.cyberark.com/threat-research-blog/execute-this-i-know-you-have-it/），原文介绍该漏洞可能会导致远程代码执行，这是相当严重的问题，因为我们知道可以执行代码往往意味着也可以执行操作系统命令，既远程命令执行，不过深入了解后发现如果要达到远程命令执行其实十分困难，对目标环境有较为苛刻的要求。【且听我娓娓道来】</p>
<h2 id="影响范围">影响范围<aside class="heading-anchor"><a href="#影响范围" aria-label="Anchor"><img src="/images/chain-link.svg" class="color-adapting-image" height="20"></a></aside></h2>
<p>kibana version &lt; 6.4.3
kibana version &lt; 5.6.13</p>
<p>可能是因为kibana大版本升级会有兼容性问题，企业内kibana几乎都是集群搭的，所以kibana 很贴心对于 5.x 版本也提供了修复补丁，很赞</p>
<h2 id="漏洞成因">漏洞成因<aside class="heading-anchor"><a href="#漏洞成因" aria-label="Anchor"><img src="/images/chain-link.svg" class="color-adapting-image" height="20"></a></aside></h2>
<p>对于漏洞成因网上已经有分析或者翻译文章，这里只简单说一下</p>
<p>如下图， require 函数接收一个变量 name ，和 <strong>./</strong> 进行拼接，并且没有任何检查，require() 函数支持使用 <strong>../</strong> 的方式完成跳目录 （ <a href="http://nodejs.cn/api/modules.html#modules_require">http://nodejs.cn/api/modules.html#modules_require</a> ）所以LFI利用便呼之欲出。</p>
<p><img src="https://raw.githubusercontent.com/D0n9/static-repo/main/images/2018/12/202402171703924.jpg" alt=""></p>
<p>然后如下图，在api类里 line:60 ~ 66 是 asJson 函数</p>
<p><img src="https://raw.githubusercontent.com/D0n9/static-repo/main/images/2018/12/202402171703430.jpg" alt=""></p>
<p>然后如下图，line: 22 AND 42，实例导出api类，提供了可控的漏洞触发点</p>
<p><img src="https://raw.githubusercontent.com/D0n9/static-repo/main/images/2018/12/202402171704700.jpg" alt=""></p>
<h2 id="漏洞复现">漏洞复现<aside class="heading-anchor"><a href="#漏洞复现" aria-label="Anchor"><img src="/images/chain-link.svg" class="color-adapting-image" height="20"></a></aside></h2>
<p>搭环境，docker 一把梭</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker pull sebp/elk:642
</span></span></code></pre></div><p>存在漏洞的url，参数是 apis ，用 ../ 实现跳目录读取，因为读到 /etc/passwd ，nodejs 会抛出异常（因为不是正常的js文件嘛）不过还是证明是存在漏洞的，但是无法将读到的文件回显出来</p>
<p>如果有办法向kibana 服务器上传一个 js 文件，使 nodejs 读取执行，就可以rce了，但是很遗憾，nodejs 并不像 php 那样灵活，nodejs 对于 require() 的文件内容有格式要求，所以像php那些类似 lfi 姿势都无法使用。</p>
<blockquote>
<p>http://127.0.0.1:32770/api/console/api_server?sense_version=%40%40SENSE_VERSION&amp;apis=es_6_0</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/D0n9/static-repo/main/images/2018/12/202402171704969.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/D0n9/static-repo/main/images/2018/12/202402171704735.jpg" alt=""></p>
<h2 id="扫描检测">扫描检测<aside class="heading-anchor"><a href="#扫描检测" aria-label="Anchor"><img src="/images/chain-link.svg" class="color-adapting-image" height="20"></a></aside></h2>
<p>服务指纹，指纹方面大版本之间会有很大差异，下面两种方法比较通用。</p>
<p>response Header</p>
<p><img src="https://raw.githubusercontent.com/D0n9/static-repo/main/images/2018/12/202402171704840.jpg" alt=""></p>
<p>request Header</p>
<p><img src="https://raw.githubusercontent.com/D0n9/static-repo/main/images/2018/12/202402171704297.jpg" alt=""></p>
<p>验证方法：</p>
<ol>
<li>方法一，对比request Header中的版本</li>
<li>方法二，先请求 【http://127.0.0.1:32770/api/console/api_server?sense_version=%40%40SENSE_VERSION&amp;apis=es_6_0】是否会返回json，如果会则发出 payload ，返回包可能会超时也可能会返回http500，基本可以确定存在漏洞，如果返回包是空json，大概率是不存在漏洞的。</li>
</ol>
<h2 id="修复建议">修复建议<aside class="heading-anchor"><a href="#修复建议" aria-label="Anchor"><img src="/images/chain-link.svg" class="color-adapting-image" height="20"></a></aside></h2>
<ol>
<li>ACL，设置访问来源白名单</li>
<li>升级到新版本</li>
<li>禁用Kibana Console插件， kibana.yml &gt; console.enabled：false</li>
<li>登录鉴权，https://www.elastic.co/guide/en/x-pack/6.0/xpack-security.html</li>
</ol>

  
  
  <div class="post-tags">
    <p>Tags: 
    
      <a href="/tags/cve">CVE</a>
    
      <a href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">漏洞分析</a>
    
      <a href="/tags/web%E5%AE%89%E5%85%A8">Web安全</a>
    
      <a href="/tags/lfi">LFI</a>
    
      <a href="/tags/kibana">Kibana</a>
    
      <a href="/tags/elasticsearch">Elasticsearch</a>
    
    </p>
  </div>
  

			</div>
		</main>
	</div>
	<hr class="dont-show">
	<footer class="footer">
		<p>Powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/stevenengler/no-js-hugo-theme">no-js-hugo-theme</a></p>
	</footer>
</body>
</html>
